{"version":3,"sources":["pages/LoginPage.tsx","pages/RegistrationPage.tsx","utils/fetch.ts","pages/RootPage.tsx","App.tsx","features/counter/counterSlice.ts","app/store.ts","serviceWorker.ts","index.tsx"],"names":["LoginPage","containerProps","marginTop","RegistrationPage","useState","username","setUsername","email","setEmail","password","setPassword","shouldShowPassword","setShouldShowPassword","isLoading","setIsLoading","errorMessage","setErrorMessage","Box","maxWidth","onSubmit","e","preventDefault","path","options","onStart","window","fetch","fetchOptions","then","response","json","ok","onSuccess","catch","error","onFailure","statusCode","finally","onEnd","body","JSON","stringify","method","data","FormControl","FormLabel","htmlFor","Input","id","isRequired","maxLength","minLength","onChange","target","value","type","InputGroup","size","width","Button","aria-label","height","onClick","variantColor","Alert","status","variant","RootPage","App","ThemeProvider","theme","CSSReset","minHeight","padding","display","flexDirection","margin","to","slice","createSlice","name","initialState","reducers","increment","state","decrement","incrementByAmount","action","payload","actions","counterReducer","reducer","rootReducer","combineReducers","counter","store","configureStore","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister","console","message"],"mappings":"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","file":"static/js/main.6ec4e122.chunk.js","sourcesContent":["import React, { FC } from 'react';\n\nexport const LoginPage: FC = () => {\n  return <h1>Login here</h1>;\n};\n","import React, { FC, useState } from 'react';\nimport {\n  Alert,\n  AlertIcon,\n  Box,\n  Button,\n  FormControl,\n  FormLabel,\n  Input,\n  InputGroup,\n  InputRightElement,\n} from '@chakra-ui/core';\n\nimport { fetch } from '../utils/fetch';\n\nconst MIN_LENGTH_USERNAME = 3;\nconst MAX_LENGTH_USERNAME = 16;\n\nconst MIN_LENGTH_PASSWORD = 8;\nconst MAX_LENGTH_PASSWORD = 64;\n\nconst containerProps = {\n  marginTop: 4,\n};\n\nexport const RegistrationPage: FC = () => {\n  const [username, setUsername] = useState('');\n  const [email, setEmail] = useState('');\n  const [password, setPassword] = useState('');\n\n  const [shouldShowPassword, setShouldShowPassword] = useState(false);\n\n  const [isLoading, setIsLoading] = useState(false);\n  const [errorMessage, setErrorMessage] = useState('');\n\n  return (\n    <Box maxWidth='500px'>\n      <form\n        onSubmit={(e): void => {\n          e.preventDefault();\n\n          fetch('/user', {\n            fetchOptions: {\n              body: JSON.stringify({\n                email,\n                password,\n                username,\n              }),\n              method: 'POST',\n            },\n            onStart: () => {\n              setIsLoading(true);\n            },\n            // eslint-disable-next-line\n            onSuccess: (data: object) => {},\n            onFailure: ({ errorMessage }) => {\n              setErrorMessage(errorMessage);\n            },\n            onEnd: () => {\n              setIsLoading(false);\n            },\n          });\n        }}\n      >\n        <FormControl {...containerProps}>\n          <FormLabel htmlFor='username'>Username</FormLabel>\n          <Input\n            id='username'\n            isRequired\n            maxLength={MAX_LENGTH_USERNAME}\n            minLength={MIN_LENGTH_USERNAME}\n            // @ts-ignore\n            onChange={({ target }): void => {\n              setUsername(target.value);\n            }}\n            type='text'\n            value={username}\n          />\n        </FormControl>\n        <FormControl {...containerProps}>\n          <FormLabel htmlFor='email'>Email address</FormLabel>\n          <Input\n            isRequired\n            id='email'\n            // @ts-ignore\n            onChange={({ target }): void => {\n              setEmail(target.value);\n            }}\n            type='email'\n            value={email}\n          />\n        </FormControl>\n        <FormControl {...containerProps}>\n          <FormLabel htmlFor='password'>Password</FormLabel>\n          <InputGroup size='md'>\n            <Input\n              id='password'\n              maxLength={MAX_LENGTH_PASSWORD}\n              minLength={MIN_LENGTH_PASSWORD}\n              // @ts-ignore\n              onChange={({ target }): void => {\n                setPassword(target.value);\n              }}\n              value={password}\n              type={shouldShowPassword ? 'text' : 'password'}\n            />\n            <InputRightElement width='4.5rem'>\n              <Button\n                aria-label='toggle password visibility'\n                height='75%'\n                size='sm'\n                onClick={(): void => {\n                  setShouldShowPassword(!shouldShowPassword);\n                }}\n              >\n                {shouldShowPassword ? 'Hide' : 'Show'}\n              </Button>\n            </InputRightElement>\n          </InputGroup>\n        </FormControl>\n        <Button isLoading={isLoading} marginTop={6} variantColor='teal' type='submit'>\n          Register\n        </Button>\n      </form>\n      {errorMessage && (\n        <Alert marginTop={6} status='error' variant='left-accent'>\n          <AlertIcon />\n          {errorMessage}\n        </Alert>\n      )}\n    </Box>\n  );\n};\n","const getEndpointURL = (): string => 'http://localhost:8080';\n\nexport function fetch<D>(\n  path: string,\n  options: {\n    fetchOptions: Parameters<typeof window.fetch>[1];\n    onEnd?: () => void;\n    onFailure: (error: { errorMessage: string; statusCode: number }) => void;\n    onStart?: () => void;\n    onSuccess: (data: D) => void;\n  },\n): Promise<void> {\n  options.onStart?.();\n\n  return window\n    .fetch(getEndpointURL() + path, options.fetchOptions)\n    .then((response: Response) => {\n      return response.json().then((json) => {\n        if (response.ok) {\n          return json;\n        }\n\n        throw json;\n      });\n    })\n    .then((json: D) => {\n      options.onSuccess(json);\n    })\n    .catch((error) => {\n      options.onFailure({\n        errorMessage: error.errorMessage || 'An unknown error has occured.',\n        statusCode: error.statusCode || 500,\n      });\n    })\n    .finally(() => {\n      options.onEnd?.();\n    });\n}\n","import React, { FC } from 'react';\n\nexport const RootPage: FC = () => {\n  return <h1>Hello World!</h1>;\n};\n","import React, { FC } from 'react';\nimport { BrowserRouter as Router, Switch, Route, Link } from 'react-router-dom';\nimport { Box, CSSReset, theme, ThemeProvider } from '@chakra-ui/core';\n\nimport { LoginPage } from './pages/LoginPage';\nimport { RegistrationPage } from './pages/RegistrationPage';\nimport { RootPage } from './pages/RootPage';\n\nconst ROOT_PATH = '/';\nconst LOGIN_PATH = '/login';\nconst REGISRATION_PATH = '/register';\n\nexport const App: FC = () => {\n  return (\n    <ThemeProvider theme={theme}>\n      <CSSReset />\n      <Box minHeight='inherit' padding='2rem'>\n        <Box\n          display='flex'\n          flexDirection='column'\n          margin='0 auto'\n          width={[\n            '100%', // base\n            '90%', // 480px upwards\n            '90%', // 768px upwards\n            '80%', // 992px upwards\n            '70%',\n          ]}\n        >\n          <Router>\n            <nav>\n              <ul>\n                <li>\n                  <Link to={ROOT_PATH}>Home</Link>\n                </li>\n                <li>\n                  <Link to={LOGIN_PATH}>Login</Link>\n                </li>\n                <li>\n                  <Link to={REGISRATION_PATH}>Register</Link>\n                </li>\n              </ul>\n            </nav>\n\n            <Switch>\n              <Route path={LOGIN_PATH}>\n                <LoginPage />\n              </Route>\n              <Route path={REGISRATION_PATH}>\n                <RegistrationPage />\n              </Route>\n              <Route path={ROOT_PATH}>\n                <RootPage />\n              </Route>\n            </Switch>\n          </Router>\n        </Box>\n      </Box>\n    </ThemeProvider>\n  );\n};\n","/* eslint-disable */\nimport { createSlice } from '@reduxjs/toolkit';\n\nexport const slice = createSlice({\n  name: 'counter',\n  initialState: {\n    value: 0,\n  },\n  reducers: {\n    increment: state => {\n      // Redux Toolkit allows us to write \"mutating\" logic in reducers. It\n      // doesn't actually mutate the state because it uses the immer library,\n      // which detects changes to a \"draft state\" and produces a brand new\n      // immutable state based off those changes\n      state.value += 1;\n    },\n    decrement: state => {\n      state.value -= 1;\n    },\n    incrementByAmount: (state, action) => {\n      state.value += action.payload;\n    },\n  },\n});\n\nexport const { increment, decrement, incrementByAmount } = slice.actions;\n\n// The function below is called a thunk and allows us to perform async logic. It\n// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This\n// will call the thunk with the `dispatch` function as the first argument. Async\n// code can then be executed and other actions can be dispatched\nexport const incrementAsync = (amount: any) => (dispatch: any) => {\n  setTimeout(() => {\n    dispatch(incrementByAmount(amount));\n  }, 1000);\n};\n\n// The function below is called a selector and allows us to select a value from\n// the state. Selectors can also be defined inline where they're used instead of\n// in the slice file. For example: `useSelector((state) => state.counter.value)`\nexport const selectCount = (state: any) => state.counter.value;\n\nexport const counterReducer = slice.reducer;\n/* eslint-enable */\n","import { combineReducers, configureStore } from '@reduxjs/toolkit';\nimport { counterReducer } from '../features/counter/counterSlice';\n\nexport type AppDispatch = typeof store.dispatch;\n\nexport type RootState = ReturnType<typeof rootReducer>;\n\nconst rootReducer = combineReducers({\n  counter: counterReducer,\n});\n\nexport const store = configureStore({\n  reducer: rootReducer,\n});\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' }\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport { App } from './App';\nimport { store } from './app/store';\nimport { Provider } from 'react-redux';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root'),\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}